(: *this-machine* symbol)
(define *this-machine*
  (cond-expand
    (x86-64 'x86_64)
    (arm64  'aarch64)
    ;; TODO: additional verification that this is armv7-a
    (arm    'armv7)
    ((and ppc64 little-endian) 'ppc64le)
    ((and ppc64 big-endian) 'ppc64)))

;; compiler tools should use <arch>-linux-musl as the system triple
(: triple ((symbol -> *) -> symbol))
(define (triple conf)
  (string->symbol
    (conc (conf 'arch) '-linux-musl)))

(: sysroot ((symbol -> *) -> string))
(define (sysroot conf)
  (filepath-join "/sysroot/" (triple conf)))

(: config-prepend ((symbol -> *) symbol list -> (symbol -> *)))
(define (config-prepend conf label lst)
  (let ((val (append lst (or (conf label) '()))))
    (lambda (sym)
      (if (eq? sym label) val (conf sym)))))

(: build-triple symbol)
(define build-triple (string->symbol
                       (conc *this-machine* "-linux-musl")))

;; cc-env takes a configuration and produces an alist
;; with typical configure/make variables set to the
;; appropriate values (CC{FLAGS}, LD{FLAGS}, CXX{FLAGS}, etc.)
(: cc-env ((symbol -> *) -> (list-of (pair symbol *))))
(define cc-env
  (memoize-eq
    (lambda (conf)
      (let ((need-cflags    `(,(sysroot-flag conf) -fPIE -static-pie))
            (need-ldflags   `(,(sysroot-flag conf) -static-pie))
            (need-cppflags  `(,(sysroot-flag conf)))
            (cflags          (conf 'CFLAGS))
            (ldflags         (conf 'LDFLAGS))
            (c++flags        (or (conf 'CXXFLAGS) (conf 'CFLAGS)))
            (plat            (triple conf))
            (join            (lambda (a b)
                               (cond
                                 ((eq? a #f) b)
                                 ((list? a)  (append a b))
                                 (else (cons a b))))))
        `((CC  . ,(conc plat "-gcc"))
          (AR  . ,(conc plat "-ar"))
          (LD  . ,(conc plat "-ld"))
          (AS  . ,(conc plat "-as"))
          (CXX . ,(conc plat "-g++"))
          (CBUILD . ,build-triple)
          (CHOST  . ,plat)
          (CFLAGS   . ,(join cflags need-cflags))
          (CXXFLAGS . ,(join c++flags need-cflags))
          (LDFLAGS  . ,(join ldflags need-ldflags)))))))

;; cc-env/build is the environment for CC_FOR_BULID and friends
(: cc-env/build (list-of (pair symbol *)))
(define cc-env/build
  (let ((need-cflags   '(-fPIE -static-pie))
        (need-ldflags  '(--sysroot=/ -static-pie))
        (plat          build-triple))
    ;; if we don't set CC_FOR_BUILD to include '--sysroot=/',
    ;; then autoconf CPP (preprocessor) checks fail, because
    ;; they won't include the sysroot flags
    ;; (note that the situation here is dire because we configure
    ;; gcc *not* to use sysroot=/ by default, so the flag *must* be used)
    `((CC_FOR_BUILD  gcc --sysroot=/)
      (CXX_FOR_BUILD g++ --sysroot=/)
      (LD_FOR_BUILD  . ,(conc plat "-ld"))
      (AR_FOR_BUILD  . ,(conc plat "-ar"))
      (AS_FOR_BUILD  . ,(conc plat "-as"))
      (RANLIB_FOR_BUILD . ,(conc plat "-ranlib"))
      (STRIP_FOR_BUILD  . ,(conc plat "-strip"))
      (NM_FOR_BUILD     . ,(conc plat "-nm"))
      (CFLAGS_FOR_BUILD   . ,need-cflags)
      (CXXFLAGS_FOR_BUILD . ,need-cflags)
      (LDFLAGS_FOR_BUILD  . ,need-ldflags))))

;; cc-env/kbuild translates cc-env/build into
;; the makefile variables that Kbuild understands...
(define (cc-env/kbuild)
  (let ((chomp (string-length "_FOR_BUILD")))
    (map
      (lambda (p)
        (cons
          (let ((old (symbol->string (car p))))
            (string->symbol
              (string-append "HOST"
                             (substring old 0 (- (string-length old) chomp)))))
          (cdr p)))
      cc-env/build)))

(define (apply-conc x)
  (if (list? x)
    (if (null? x)
      ""
      (let ((lst (let loop ((head (car x))
                            (rest (cdr x)))
                   (if (null? rest)
                     (cons head '())
                     (cons head (cons " " (loop (car rest) (cdr rest))))))))
        (apply conc lst)))
    x))

(define (pair->string= p) (conc (car p) "=" (apply-conc (cdr p))))

;; configure-args produces arguments to an autotools configure script
;; NOTE: some packages contain a script called 'configure' that isn't
;; actually generated by autoconf, in which case this function may not produce
;; appropriate arguments
(define configure-args
  (memoize-eq
    (lambda (conf)
      (let ((need-conf `(--disable-shared --disable-nls --enable-static --enable-pie --with-pic --prefix=/usr --sysconfdir=/etc --build ,build-triple --host ,(triple conf)))
            (usr-conf  (conf 'configure-flags)))
        (cond
          ((eq? usr-conf #f) need-conf)
          ((list? usr-conf)  (append usr-conf need-conf))
          (else              (cons usr-conf need-conf)))))))

(define (export* alist)
  (map (lambda (p)
         `(export ,(car p) ,(apply-conc (cdr p))))
       alist))

;; we don't use tools just name 'ar' etc.
;; because they would conflict if multiple
;; binutils targets were installed
;;
;; let make know what we call these tools explicitly
(define (make-env target)
  (let ((name (triple target)))
    (list
      (cons 'AR      (conc name "-ar"))
      (cons 'RANLIB  (conc name "-ranlib"))
      (cons 'STRIP   (conc name "-strip"))
      (cons 'READELF (conc name "-readelf"))
      (cons 'OBJCOPY (conc name "-objcopy"))
      (cons 'ARFLAGS '-Dcr))))

(define (+cross conf normal extra)
  (if (eq? (conf 'arch) *this-machine*)
    normal
    (append extra normal)))

;; generator for an execline sequence that strips binaries
(define (strip-binaries-script target)
  (execline*
    (forbacktickx file ((find /out -type f -perm -o+x)))
    (importas "-i" -u file file)
    (backtick prefix ((head -c4 $file)))
    (importas "-i" -u prefix prefix)
    ;; the execline printing code knows
    ;; how to escape a raw byte sequence
    ;; (elf binaries begin with (0x7f)ELF)
    (if ((test $prefix "=" #u8(127 69 76 70))))
    (if ((echo "strip" $file)))
    (,(conc (triple target) "-strip") $file)))

;; patch* creates a series of patch artifacts
;; from a collection of verbatim strings
(define (patch* . patches)
  (if (null? patches)
    '()
    (let loop ((n 0)
               (head (car patches))
               (rest (cdr patches)))
      (cons
        (interned (conc "/src/patch-" n ".patch") #o644 head)
        (if (null? rest) '() (loop (+ n 1) (car rest) (cdr rest)))))))

;; script-apply-patches produces the execline expressions
;; for applying a series of patches from artifact files
(define (script-apply-patches lst)
  (map
    (lambda (pf)
      `(if ((patch -p1 "-i" ,(vector-ref (vector-ref pf 0) 1)))))
    lst))

(define (sysroot-flag conf)
  (string-append "--sysroot=" (sysroot conf)))

;; wrapper around the 'configure;make;make install' pattern,
;; taking care to set configure flags make flags appropriately
;; for the common case that we're dealing with autotools
(define (gnu-build dir target #!key
                   (pre-configure '())
                   (post-install '())
                   (make-flags '())
                   (out-of-tree #f) ;; build out of tree
                   (configure #f))  ;; alternate configure flags
  (make-recipe
    script: (execline*
              (cd ,dir)
              ,@pre-configure
              ,@(export* (cc-env target))
              ;; if we're doing an out-of-tree build,
              ;; move the rest of the build to /builddir
              ,@(if out-of-tree
                  `((if ((mkdir -p "/builddir")))
                    (cd "/builddir")
                    (if ((,(conc "/" dir "/configure")
                           ,@(or configure (configure-args target))))))
                  `((if ((./configure ,@(or configure (configure-args target)))))))
              ;; it's helpful (mandatory?) that the script not change
              ;; based on the number of cpus on the host, so we have
              ;; to make that determination in the script itself
              (if ((importas -u "-i" nproc nproc)
                   (make -j $nproc ,@(append
                                      (makeflags target)
                                      make-flags))))
              (if ((make DESTDIR=/out install)))
              ,@post-install
              ;; we don't care if these two succeed
              ;; TODO: perhaps gnu packages should
              ;; symlink makeinfo to /usr/bin/true
              (foreground ((rm -rf /out/usr/share/man)))
              (foreground ((rm -rf /out/usr/share/info)))
              ;; the presence of libtool archives in library output
              ;; actually breaks builds, because libtool doesn't
              ;; undestand --sysroot, etc
              (foreground ((find /out -type f -name "*.la" -delete)))
              ,@(strip-binaries-script target))))


(define (ska-build dir conf #!key (extra-configure '()))
  (let ((cenv    (cc-env conf))
        (sysrt   (sysroot conf)))
    (make-recipe
      script: (execline*
                (cd ,dir)
                ,@(export* cenv)
                (if ((sed "-i" -e "/^tryflag.*-fno-stack/d" -e "s/^CFLAGS=.*$/CFLAGS=/g" configure)))
                (if ((./configure --target ,(triple conf) --prefix=/ --libdir=/usr/lib
                                  ,(conc "--with-include=" (filepath-join sysrt "/include"))
                                  ,(conc "--with-include=" (filepath-join sysrt "/usr/include"))
                                  ,(conc "--with-lib=" (filepath-join sysrt "/lib"))
                                  ,(conc "--with-lib=" (filepath-join sysrt "/usr/lib"))
                                  --disable-shared --enable-static ,@extra-configure)))
                (if ((importas -u "-i" nproc nproc)
                     (make -j $nproc ,@(makeflags conf))))
                (if ((make DESTDIR=/out install)))
                ,@(strip-binaries-script conf)))))


(define (makeflags target) (map pair->string= (make-env target)))

